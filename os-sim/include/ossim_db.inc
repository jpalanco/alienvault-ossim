<?php
/**
* ossim_db.inc
*
* File ossim_db.inc is used to:
*   - Manage connections with different databases
*
*
* License:
*
* Copyright (c) 2003-2006 ossim.net
* Copyright (c) 2007-2013 AlienVault
* All rights reserved.
*
* This package is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; version 2 dated June, 1991.
* You may not use, modify or distribute this program under any other version
* of the GNU General Public License.
*
* This package is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this package; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
* MA  02110-1301  USA
*
*
* On Debian GNU/Linux systems, the complete text of the GNU General
* Public License can be found in `/usr/share/common-licenses/GPL-2'.
*
* Otherwise you can read it here: http://www.gnu.org/licenses/gpl-2.0.txt
*
* @package    ossim-framework\Database
* @autor      AlienVault INC
* @license    http://www.gnu.org/licenses/gpl-2.0.txt
* @copyright  2003-2006 ossim.net
* @copyright  2007-2013 AlienVault
* @link       https://www.alienvault.com/
*/


/**
* Ossim_db Class
*
* Class for managing connections with different databases
*
* @package    ossim-framework\Database
* @autor      AlienVault INC
* @copyright  2007-2013 AlienVault
* @link       https://www.alienvault.com/ Alienvault web page
*/
class Ossim_db
{    
    /**
    * Memcached options
    *
    * @var array
    * @access private
    */ 
    private $memcached_opts;         
    
    /**
    * Configuration array
    *
    * @var array
    * @access private
    */ 
    private $conf;    
    
    /**
    * Last error generated by the class
    *
    * @var string
    * @access private
    */  
    private $err;    
    
    /**
    * Connection object
    *
    * @var array
    * @access private
    */ 
    private $conn;
            
        
    /**
    * Class constructor
    *
    * This function sets up the class
    *
    * @param string $cache  [Optional] Enable or disable Memcached
    */
    public function __construct($cache = FALSE) 
    {             
        $_conf = new Ossim_conf(FALSE);        
                               
        if (!is_object($_conf))
        {         
            Av_exception::throw_error(Av_exception::USER_ERROR, _('OSSIM configuration not found'));
        }
                
        $conf_errors = $_conf->get_errors();
                        
        if (is_array($conf_errors) && !empty($conf_errors))
        {         
            $exp_msg = $conf_errors[0];
            Av_exception::throw_error(Av_exception::USER_ERROR, $exp_msg);
        }
               
        
        $this->conf = $_conf;       
        
        if ($this->conf->get_conf('ossim_type') == 'mysql' && !function_exists('mysql_connect')) 
        {   
            $exp_msg = _('No mysql support available in your PHP installation, try installing the php-mysql extension/package');
            
            Av_exception::throw_error(Av_exception::PHP_ERROR, $exp_msg);
        }
        
        $adodb_path = $this->conf->get_conf('adodb_path');
        
        if (!is_readable($adodb_path)) 
        {
            $error   = new Av_error('ADODB_PATH');            
            $exp_msg = $error->get_message();
            
            Av_exception::throw_error(Av_exception::PHP_ERROR, $exp_msg);
               
        }
                
        require_once "$adodb_path/adodb.inc.php";
        
        /* Patch: $GLOBALS has been cleaned, must re-setup
         * In phpUnit the second test is clean, but adodb.inc.php is already required
         * So we are missing the ADDB_Setup() calling by adodb.inc.php at line 195
         */
        if (!$GLOBALS['ADODB_vers'])
        {
            ADODB_Setup();
        }
        
        $this->conn = NULL;
        
        $this->err  = NULL;        
        
        $cache = ($cache === TRUE) ? TRUE : FALSE;
        
        $this->memcached_opts = array(
            'enabled'  => $cache,           // Disabled by default 
            'time'     => 60,                   // Max cache time
            'host'     => array("127.0.0.1"),   // $db->memCacheHost = $ip1; will work too
            'port'     => 11211,                // This is default memCache port
            'compress' => 0                     // Use 0 or 1 to store the item compressed (uses zlib)
        ); 
    }
		  
   
    /**
    * This function returns credentials for connecting with database $db_name
    *
    * @param string $db_name  [Optional] Database name
    *
    * @return array 
    */
    private function get_db_credentials($db_name = 'alienvault')
    {
        $db_credentials = array(NULL, NULL, NULL, NULL, NULL);
        
       /*
        * $db_credentials:
        *  [0] - type
        *  [1] - base
        *  [2] - host
        *  [3] - user
        *  [4] - pass
        */
                
        switch($db_name)
        {
            case 'alienvault':
            case 'alienvault_siem':
                $db_credentials[0] = $this->conf->get_conf('ossim_type');
                $db_credentials[1] = $this->conf->get_conf('ossim_base');
                $db_credentials[2] = $this->conf->get_conf('ossim_host');
                $db_credentials[3] = $this->conf->get_conf('ossim_user');
                $db_credentials[4] = $this->conf->get_conf('ossim_pass');                
            break;
            
            case 'custom':
                $db_credentials[0] = $this->conf->get_conf('ossim_type');
                $db_credentials[1] = $this->conf->get_conf('ossim_base');
            break;
                    
            case 'opennms':
                $db_credentials[0] = $this->conf->get_conf('opennms_type');
                $db_credentials[1] = $this->conf->get_conf('opennms_base');
                $db_credentials[2] = $this->conf->get_conf('opennms_host');
                $db_credentials[3] = $this->conf->get_conf('opennms_user');
                $db_credentials[4] = $this->conf->get_conf('opennms_pass'); 
            break;
                                  
            case 'osvdb':
                $db_credentials[0] = $this->conf->get_conf('osvdb_type');
                $db_credentials[1] = $this->conf->get_conf('osvdb_base');
                $db_credentials[2] = $this->conf->get_conf('osvdb_host');
                $db_credentials[3] = $this->conf->get_conf('osvdb_user');
                $db_credentials[4] = $this->conf->get_conf('osvdb_pass');            
            break;
            
            case 'phpgacl':
                $db_credentials[0] = $this->conf->get_conf('phpgacl_type');
                $db_credentials[1] = $this->conf->get_conf('phpgacl_base');
                $db_credentials[2] = $this->conf->get_conf('phpgacl_host');
                $db_credentials[3] = $this->conf->get_conf('phpgacl_user');
                $db_credentials[4] = $this->conf->get_conf('phpgacl_pass');            
            break;
        }
        
        
        /* ossim_type forced to 'mysqli' when ossim_type is 'mysql' here
         * ossim_type into ossim.conf has to be 'mysql'
         * Some perl scripts depends on it and it may causes a server fail
         */
         if ($db_credentials[0] == 'mysql')
         {
             $db_credentials[0] = 'mysqli';
         }      
        
         return $db_credentials;        
    }
    
    
    /**
    * This function sets cache options for current connection
    *
    * @return void 
    */
    private function set_adodb_cache_options()
    {   
        if (self::check_connection($this->conn, FALSE))
        {
            $this->conn->cacheSecs        = $this->memcached_opts['time'];
            $this->conn->memCache         = $this->memcached_opts['enabled'];
            $this->conn->memCacheHost     = $this->memcached_opts['host'];   
            $this->conn->memCachePort     = $this->memcached_opts['port']; 
            $this->conn->memCacheCompress = $this->memcached_opts['compress'];            
        }          
    }
    
    
    /**
    * This function sets cache time
    *
    * @param int $cache_time  Max cache time
    *
    * @return void 
    */
    public function set_cache_time($cache_time) 
    {
        $this->memcached_opts['time'] = $cache_time;
        $this->set_adodb_cache_options();
    }
    
    
    /**
    * This function enables Memcached
    *
    * @return void 
    */
    public function enable_cache() 
    {
        $this->memcached_opts['enabled'] = TRUE;
        $this->set_adodb_cache_options();
    }
    
    
    /**
    * This function disables Memcached
    *
    * @return void 
    */
    public function disable_cache() 
    {
        $this->memcached_opts['enabled'] = FALSE;
        $this->set_adodb_cache_options();
    }
    
    
    /**
    * This function retrieves last error generated by the class
    *
    * @return void 
    */
    public function get_error() 
    {
        return $this->err;
    }
    	  
    
    /**
    * This function connects with database (Default connection)
    *
    * @return void 
    */
    public function connect() 
    {
        //return $this->nconnect();
        return $this->pconnect(); 
    }

    
    /**
    * This function tests default connection
    *
    * @return void 
    */
    public function test_connect() 
    {           
        $conn_status = TRUE;
        
        try
        {
            $this->connect();
        }
        catch(Exception $e)
        {
            $conn_status = FALSE;
        }
               
        return $conn_status;
    }

    
    /**
    * This function establishes a persistent connection with database (Alienvault) and returns the connection object
    *
    * @throws Exception  If a connection error occurred
    * 
    * @return object  
    */
    public function pconnect() 
    {          
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('alienvault');        
        
        $this->conn = &ADONewConnection($av_type);
                
        $this->set_adodb_cache_options();
                                
        $this->err = @$this->conn->PConnect($av_host, $av_user, $av_pass, $av_base);
        
        if (!$this->err)
        {                     
           $this->close();           
           
           $exp_msg = _('Error! Unable to connect to Database');
            
           Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }
                        
        return $this->conn;
    }
    
    
    /**
    * This function forces a new connection with database and returns the connection object
    *
    * @param string $db_base  [Optional] Database prefix
    *
    * @throws Exception  If a connection error occurred
    * 
    * @return object  
    */
    public function nconnect($db_base = '') 
    {     
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('alienvault_siem');  
                
        $av_base = $av_base.$db_base;
                       
        $this->conn = &ADONewConnection($av_type);
        
        $this->set_adodb_cache_options();             
        
        $this->err = @$this->conn->NConnect($av_host, $av_user, $av_pass, $av_base);
        
        if (!$this->err)
        {                     
           $this->close();
           
           $exp_msg = _('Error! Unable to connect to Database');
            
           Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }
                       
        return $this->conn;
    }
          
    
    /**
    * This function establishes a persistent customized connection with database (Alienvault) and returns the connection object
    *
    * @param string $host  Database server
    * @param string $user  Database user
    * @param string $pass  User password
    *
    * @throws Exception  If a connection error occurred
    * 
    * @return object             
    */
    public function custom_connect($host, $user, $pass) 
    {    	       
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('custom'); 

        $this->conn = &ADONewConnection($av_type);
        
        if ($av_type == 'mysqli' && preg_match("/(.*):(\d+)/",$host,$found)) 
        {
            $av_host          = $found[1];
            $this->conn->port = $found[2];
        }
        else
        {
            $av_host = $host;            
        }
        $av_user = $user;
        $av_pass = $pass;
                
        $this->set_adodb_cache_options();       
                        
        $this->err = @$this->conn->PConnect($av_host, $av_user, $av_pass, $av_base);
        
        if (!$this->err)
        {                     
            $this->close();
            
            $exp_msg = _('Error! Unable to connect to Database');
            
            Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }
        
        return $this->conn;
    }
    
    
    /**
    * This function returns a connection object for database Alienvault_siem
    *
    * @throws Exception  If a connection error occurred
    * 
    * @return object             
    */  
    public function snort_connect() 
    {
        return $this->nconnect('_siem');
    }
    
    
    /**
    * This function returns a connection object for database OpenNMS
    *
    * @deprecated 4.2.0
    *
    * @throws Exception  If a connection error occurred
    * 
    * @return object             
    */  
    public function opennms_connect() 
    {     
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('opennms'); 
                
        $this->conn = &ADONewConnection($av_type);
                        
        $this->set_adodb_cache_options();
             
        $this->err = @$this->conn->PConnect($av_host, $av_user, $av_pass, $av_base);
        
        if (!$this->err)
        {                     
            $this->close();
           
            $exp_msg = _('Error! Unable to connect to Database');
            
            Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }
                        
        return $this->conn;
    }
    
    
    /**
    * This function returns a connection object for database PHPGACL
    *
    * @deprecated 4.2.0
    *
    * @throws Exception  If a connection error occurred
    * 
    * @return object             
    */    
    public function phpgacl_connect() 
    {
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('phpgacl'); 
                        
        $this->conn = & ADONewConnection($av_type);        
        
        $this->set_adodb_cache_options();
                
        $this->err = @$this->conn->NConnect($av_host, $av_user, $av_pass, $av_base);        
        
        if (!$this->err)
        {                     
            $this->close();
           
            $exp_msg = _('Error! Unable to connect to Database');
            
            Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }
                        
        return $this->conn;                  
    }
   
        
    /**
    * This function returns a connection object for database OSVDB
    *
    * @deprecated 4.2.0
    * @throws Exception  If a connection error occurred
    * 
    * @return object             
    */    
    public function osvdb_connect() 
    {
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('osvdb'); 
                
        $this->conn = & ADONewConnection($av_type);
                
        $this->set_adodb_cache_options();
        
        $this->err = @$this->conn->NConnect($av_host, $av_user, $av_pass, $av_base);        
        
        if (!$this->err)
        {                     
            $this->close();
           
            $exp_msg = _('Error! Unable to connect to Database');
            
            Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }
                        
        return $this->conn;
    }
    
    
    /**
    * This function closes a database connection
    *
    *  @return void             
    */  
    public function close() 
    {
        $this->conn->Close();
    }
    
    
    /**
    * This function returns the max value of column $column in table $table
    *
    * @param object $conn    Database access object
    * @param string $column  Column name
    * @param string $table   Table name
    * @param string $where   [Optional] SQL condition
    *
    * @deprecated  It will be deprecated in the future 
    * @throws Exception  If a connection error occurred
    * 
    * @return string             
    */   
    public function max_val($conn, $column, $table, $where = '') 
    {
        $query = "SELECT max($column) FROM $table $where;";
        
        $rs = $conn->Execute($query);
        if (!$rs)
        {         
            Av_exception::throw_error(Av_exception::DB_ERROR, $conn->ErrorMsg());
        } 
        
        if (!$rs->EOF) 
        {
            return $rs->fields["max($column)"];
        }
    }
    
    
    /**
    * This function returns the descendent order of column
    *
    * @param string $column  Column name
    * @param string $order   Order (ASC or DESC)
    *
    * @deprecated  It will be deprecated in the future 
    * 
    * @return string             
    */   
    public function get_order($column, $order) 
    {
        if ($order == $column) 
        {
            return "$order DESC";
        } 
        
        return $column;        
    }
    
    /**
    * This function returns the ascendent order of column
    *
    * @param string $column  Column name
    * @param string $order   Order (ASC or DESC)
    *
    * @deprecated  It will be deprecated in the future 
    * 
    * @return string             
    */   
    public function get_aorder($column, $order) 
    {
    	if ($order == $column) 
    	{
            return "$order ASC";
        } 
       
        return "$column DESC";        
    }
    
    
    
    /*************************************************        
     *************** Static functions ****************      
     *************************************************/
    
    /**
    * This function checks database connection object
    *
    * @param object   $conn        Database access object
    * @param boolean  $throw_exp   If true, method throws exception
    *
    * @throws Exception  If DAO isn't an object or empty
    *
    * @return boolean
    */ 
    public static function check_connection($conn, $throw_exp = TRUE)
    {
        $conn_status = TRUE;
        
        if (!is_object($conn) || $conn == NULL)
        {
            $conn_status = FALSE;
        }
        
        if ($throw_exp == TRUE && $conn_status == FALSE)
        {
            $exp_msg = _('Error! Unable to connect to Database');
            
            Av_exception::throw_error(Av_exception::DB_ERROR, $exp_msg);
        }        
        
        return $conn_status;        
    } 
    
     
    /**
    * This function returns a connection object for database $db_name
    *
    * @param string $db_name  [Optional] Database name
    * @param string $cache    [Optional] Enable or disable Memcached
    *
    * @return object|void             
    */ 
    public static function get_conn_db($db_name = 'alienvault', $cache = TRUE)
    {
        try
        {            
            $db   = new Ossim_db($cache);
            $conn = NULL;              
            
            switch($db_name)
            {
                case 'alienvault':
                    $conn = $db->connect();
                break;
                
                case 'alienvault_siem':
                    $conn = $db->snort_connect();
                break;
                
                case 'opennms':
                    $conn = $db->opennms_connect();
                break;
                
                case 'osvdb':
                    $conn = $db->osvdb_connect();
                break;
            }            
            
            if ($conn !== NULL)
            {
                return array($db, $conn);
            }
            else
            {
                $error = new Av_error(_('Error! Database not found'));
                $error->display();                             
            }            
        }
        catch(Exception $e)
        {                       
            $error = new Av_error($e->getMessage());
            $error->display();     
        }
    }
    
    
    /**
    * This functions returns the total elements from FOUND_ROWS
    *
    * @param object $db_name    [Optional] Database name
    * @param string $query      Query that has been executed and where we are going to count.
    * @param string $cache      [Optional] Enable or disable Memcached
    *
    * @throws Exception  If a connection error occurred
    *
    * @return integer             
    */ 
    public static function get_found_rows($conn, $query, $cache = FALSE)
    {
        $total = 0;
        
        if ($cache == TRUE)
        {
            $counter_name = 'total_'.md5($query);
            
            $query        = "SELECT FOUND_ROWS() AS $counter_name";
              
            $rf           = $conn->CacheExecute($query);
        }
        else
        {
            $counter_name = 'total';
            
            $query        = "SELECT FOUND_ROWS() AS $counter_name";
            
            $rf           = $conn->Execute($query);
        }

        if (!$rf) 
        {                
            Av_exception::throw_error(Av_exception::DB_ERROR, $conn->ErrorMsg());
        }
        
        if (!$rf->EOF) 
        {                
            $total = $rf->fields[$counter_name];
        }
        
        return intval($total);
    }
}

/* End of file ossim_db.inc */
/* Location: ../include/ossim_db.inc */