<?php
/**
* ossim_db.inc
*
* File ossim_db.inc is used to:
*   - Manage connections with different databases
*
*
* License:
*
* Copyright (c) 2003-2006 ossim.net
* Copyright (c) 2007-2013 AlienVault
* All rights reserved.
*
* This package is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; version 2 dated June, 1991.
* You may not use, modify or distribute this program under any other version
* of the GNU General Public License.
*
* This package is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this package; if not, write to the Free Software
* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
* MA  02110-1301  USA
*
*
* On Debian GNU/Linux systems, the complete text of the GNU General
* Public License can be found in `/usr/share/common-licenses/GPL-2'.
*
* Otherwise you can read it here: http://www.gnu.org/licenses/gpl-2.0.txt
*
* @package    ossim-framework\Database
* @autor      AlienVault INC
* @license    http://www.gnu.org/licenses/gpl-2.0.txt
* @copyright  2003-2006 ossim.net
* @copyright  2007-2013 AlienVault
* @link       https://www.alienvault.com/
*/


/**
* Ossim_db Class
*
* Class for managing connections with different databases
*
* @package    ossim-framework\Database
* @autor      AlienVault INC
* @copyright  2007-2013 AlienVault
* @link       https://www.alienvault.com/ AlienVault web page
*/
class Ossim_db
{
    /**
    * Memcached options
    *
    * @var array
    * @access private
    */
    private $memcached_opts;

    /**
    * Configuration array
    *
    * @var array
    * @access private
    */
    private $conf;

    /**
    * Last error generated by the class
    *
    * @var string
    * @access private
    */
    private $err;

    /**
    * Connection object
    *
    * @var array
    * @access private
    */
    private $conn;

    /**
    * Connection tries
    *
    * @var integer
    * @access private
    */
    private $tries;

    /**
    * Class constructor
    *
    * This function sets up the class
    *
    * @param string $cache  [Optional] Enable or disable Memcached
    */
    public function __construct($cache = FALSE)
    {
        $_conf = new Ossim_conf(FALSE);

        if (!is_object($_conf))
        {
            Av_exception::throw_error(Av_exception::USER_ERROR, _('OSSIM configuration not found'));
        }

        $conf_errors = $_conf->get_errors();

        if (is_array($conf_errors) && !empty($conf_errors))
        {
            $exp_msg = $conf_errors[0];
            Av_exception::throw_error(Av_exception::USER_ERROR, $exp_msg);
        }


        $this->conf = $_conf;

        if ($this->conf->get_conf('ossim_type') == 'mysql' && !function_exists('mysqli_connect'))
        {
            $exp_msg = _('No mysql support available in your PHP installation, try installing the php-mysql extension/package');

            Av_exception::throw_error(Av_exception::PHP_ERROR, $exp_msg);
        }

        $adodb_path = $this->conf->get_conf('adodb_path');

        if (!is_readable($adodb_path))
        {
            $error   = new Av_error('ADODB_PATH');
            $exp_msg = $error->get_message();

            Av_exception::throw_error(Av_exception::PHP_ERROR, $exp_msg);

        }

        require_once "$adodb_path/adodb.inc.php";

        /* Patch: $GLOBALS has been cleaned, must re-setup
         * In phpUnit the second test is clean, but adodb.inc.php is already required
         * So we are missing the ADDB_Setup() calling by adodb.inc.php at line 195
         */
        if (!$GLOBALS['ADODB_vers'])
        {
            ADODB_Setup();
        }

        $this->conn  = NULL;

        $this->err   = NULL;

        $this->tries = 3;

        $cache = ($cache === TRUE) ? TRUE : FALSE;

        $this->memcached_opts = array(
            'enabled'  => $cache,           // Disabled by default
            'time'     => 60,                   // Max cache time
            'host'     => array("127.0.0.1"),   // $db->memCacheHost = $ip1; will work too
            'port'     => 11211,                // This is default memCache port
            'compress' => 0                     // Use 0 or 1 to store the item compressed (uses zlib)
        );
    }


    /**
    * This function returns credentials for connecting with database $db_name
    *
    * @param string $db_name  [Optional] Database name
    *
    * @return array
    */
    private function get_db_credentials($db_name = 'alienvault')
    {
        $db_credentials = array(NULL, NULL, NULL, NULL, NULL);

       /*
        * $db_credentials:
        *  [0] - type
        *  [1] - base
        *  [2] - host
        *  [3] - user
        *  [4] - pass
        */

        switch($db_name)
        {
            case 'alienvault':
            case 'alienvault_siem':
                $db_credentials[0] = $this->conf->get_conf('ossim_type');
                $db_credentials[1] = $this->conf->get_conf('ossim_base');
                $db_credentials[2] = $this->conf->get_conf('ossim_host');
                $db_credentials[3] = $this->conf->get_conf('ossim_user');
                $db_credentials[4] = $this->conf->get_conf('ossim_pass');
            break;

            case 'custom':
                $db_credentials[0] = $this->conf->get_conf('ossim_type');
                $db_credentials[1] = $this->conf->get_conf('ossim_base');
            break;
        }


        /* ossim_type forced to 'mysqli' when ossim_type is 'mysql' here
         * ossim_type into ossim.conf has to be 'mysql'
         * Some perl scripts depends on it and it may causes a server fail
         */
         if ($db_credentials[0] == 'mysql')
         {
             $db_credentials[0] = 'mysqli';
         }

         return $db_credentials;
    }


    /**
    * This function sets cache options for current connection
    *
    * @return void
    */
    private function set_adodb_cache_options()
    {
        if (self::check_connection($this->conn, FALSE))
        {
            $this->conn->cacheSecs        = $this->memcached_opts['time'];
            $this->conn->memCache         = $this->memcached_opts['enabled'];
            $this->conn->memCacheHost     = $this->memcached_opts['host'];
            $this->conn->memCachePort     = $this->memcached_opts['port'];
            $this->conn->memCacheCompress = $this->memcached_opts['compress'];
        }
    }


    /**
    * This function sets cache time
    *
    * @param int $cache_time  Max cache time
    *
    * @return void
    */
    public function set_cache_time($cache_time)
    {
        $this->memcached_opts['time'] = $cache_time;
        $this->set_adodb_cache_options();
    }


    /**
    * This function enables Memcached
    *
    * @return void
    */
    public function enable_cache()
    {
        $this->memcached_opts['enabled'] = TRUE;
        $this->set_adodb_cache_options();
    }


    /**
    * This function disables Memcached
    *
    * @return void
    */
    public function disable_cache()
    {
        $this->memcached_opts['enabled'] = FALSE;
        $this->set_adodb_cache_options();
    }


    /**
    * This function retrieves last error generated by the class
    *
    * @return void
    */
    public function get_error()
    {
        return $this->err;
    }


    /**
    * This function connects with database (Default connection)
    *
    * @return void
    */
    public function connect()
    {
        //return $this->nconnect();
        return $this->pconnect();
    }


    /**
    * This function tests default connection
    *
    * @return void
    */
    public function test_connect()
    {
        $conn_status = TRUE;

        try
        {
            $this->connect();
        }
        catch(Exception $e)
        {
            $conn_status = FALSE;
            Av_exception::write_log(Av_exception::DB_ERROR, $e->getMessage());
        }

        return $conn_status;
    }


    /**
    * This function establishes a persistent connection with database (AlienVault) and returns the connection object
    *
    * @throws Exception  If a connection error occurred
    *
    * @return object
    */
    public function pconnect()
    {
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('alienvault');

        $this->conn = ADONewConnection($av_type);

        $this->set_adodb_cache_options();

        $tries = $this->tries;
        do
        {
            $tries--;

            $this->err = @$this->conn->PConnect($av_host, $av_user, $av_pass, $av_base);

            if (!$this->err)
            {
               if ($tries > 0)
               {
                   sleep(2);
               }
               else
               {
                   $this->close();

                   Av_exception::throw_error(Av_exception::DB_ERROR, $this->conn->ErrorMsg());
               }
            }
            else
            {
                $tries = 0;
            }
        }
        while ($tries);

        return $this->conn;
    }


    /**
    * This function forces a new connection with database and returns the connection object
    *
    * @param string $db_base  [Optional] Database prefix
    *
    * @throws Exception  If a connection error occurred
    *
    * @return object
    */
    public function nconnect($db_base = '')
    {
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('alienvault_siem');

        $av_base = $av_base.$db_base;

        $this->conn = ADONewConnection($av_type);

        $this->set_adodb_cache_options();

        $tries = $this->tries;
        do
        {
            $tries--;

            $this->err = @$this->conn->NConnect($av_host, $av_user, $av_pass, $av_base);

            if (!$this->err)
            {
               if ($tries > 0)
               {
                   sleep(2);
               }
               else
               {
                   $this->close();

                   Av_exception::throw_error(Av_exception::DB_ERROR, $this->conn->ErrorMsg());
               }
            }
            else
            {
                $tries = 0;
            }
        }
        while ($tries);

        return $this->conn;
    }


    /**
    * This function establishes a persistent customized connection with database (AlienVault) and returns the connection object
    *
    * @param string $host  Database server
    * @param string $user  Database user
    * @param string $pass  User password
    *
    * @throws Exception  If a connection error occurred
    *
    * @return object
    */
    public function custom_connect($host, $user, $pass)
    {
        list($av_type, $av_base, $av_host, $av_user, $av_pass) = $this->get_db_credentials('custom');

        $this->conn = ADONewConnection($av_type);

        if ($av_type == 'mysqli' && preg_match("/(.*):(\d+)/",$host,$found))
        {
            $av_host          = $found[1];
            $this->conn->port = $found[2];
        }
        else
        {
            $av_host = $host;
        }
        $av_user = $user;
        $av_pass = $pass;

        $this->set_adodb_cache_options();

        $tries = $this->tries;
        do
        {
            $tries--;

            $this->err = @$this->conn->PConnect($av_host, $av_user, $av_pass, $av_base);

            if (!$this->err)
            {
               if ($tries > 0)
               {
                   sleep(2);
               }
               else
               {
                   $this->close();

                   Av_exception::throw_error(Av_exception::DB_ERROR, $this->conn->ErrorMsg());
               }
            }
            else
            {
                $tries = 0;
            }
        }
        while ($tries);

        return $this->conn;
    }


    /**
    * This function returns a connection object for database AlienVault_siem
    *
    * @throws Exception  If a connection error occurred
    *
    * @return object
    */
    public function snort_connect()
    {
        return $this->nconnect('_siem');
    }


    /**
    * This function closes a database connection
    *
    *  @return void
    */
    public function close()
    {
        $this->conn->Close();
    }


    /**
    * This function returns the max value of column $column in table $table
    *
    * @param object $conn    Database access object
    * @param string $column  Column name
    * @param string $table   Table name
    * @param string $where   [Optional] SQL condition
    *
    * @deprecated  It will be deprecated in the future
    * @throws Exception  If a connection error occurred
    *
    * @return string
    */
    public static function max_val($conn, $column, $table, $where = '')
    {
        $query = "SELECT max($column) FROM $table $where;";

        $rs = $conn->Execute($query);
        if (!$rs)
        {
            Av_exception::throw_error(Av_exception::DB_ERROR, $conn->ErrorMsg());
        }

        if (!$rs->EOF)
        {
            return $rs->fields["max($column)"];
        }
    }


    /**
    * This function returns the descendent order of column
    *
    * @param string $column  Column name
    * @param string $order   Order (ASC or DESC)
    *
    * @deprecated  It will be deprecated in the future
    *
    * @return string
    */
    public static function get_order($column, $order)
    {
        if ($order == $column)
        {
            return "$order DESC";
        }

        return $column;
    }

    /**
    * This function returns the ascendent order of column
    *
    * @param string $column  Column name
    * @param string $order   Order (ASC or DESC)
    *
    * @deprecated  It will be deprecated in the future
    *
    * @return string
    */
    public function get_aorder($column, $order)
    {
    	if ($order == $column)
    	{
            return "$order ASC";
        }

        return "$column DESC";
    }



    /*************************************************
     *************** Static functions ****************
     *************************************************/

    /**
    * This function checks database connection object
    *
    * @param object   $conn        Database access object
    * @param boolean  $throw_exp   If true, method throws exception
    *
    * @throws Exception  If DAO isn't an object or empty
    *
    * @return boolean
    */
    public static function check_connection($conn, $throw_exp = TRUE)
    {
        $conn_status = TRUE;

        if (!is_object($conn) || $conn == NULL)
        {
            $conn_status = FALSE;
        }

        if ($throw_exp == TRUE && $conn_status == FALSE)
        {
            $error_msg = $conn_status ? $conn->ErrorMsg() : _('Unexpected DB Error Found');
            Av_exception::throw_error(Av_exception::DB_ERROR, $error_msg);
        }

        return $conn_status;
    }


    /**
    * This function returns a connection object for database $db_name
    *
    * @param string $db_name  [Optional] Database name
    * @param string $cache    [Optional] Enable or disable Memcached
    *
    * @return object|void
    */
    public static function get_conn_db($db_name = 'alienvault', $cache = TRUE)
    {
        try
        {
            $db   = new Ossim_db($cache);
            $conn = NULL;

            switch($db_name)
            {
                case 'alienvault':
                    $conn = $db->connect();
                break;

                case 'alienvault_siem':
                    $conn = $db->snort_connect();
                break;
            }

            if ($conn !== NULL)
            {
                return array($db, $conn);
            }
            else
            {
                $error = new Av_error(_('Error! Database not found'));
                $error->display();
            }
        }
        catch(Exception $e)
        {
            $error = new Av_error($e->getMessage());
            $error->display();
        }
    }


    /**
    * This functions returns the total elements from FOUND_ROWS
    *
    * @param object $db_name    [Optional] Database name
    * @param string $query      Query that has been executed and where we are going to count.
    * @param string $cache      [Optional] Enable or disable Memcached
    *
    * @throws Exception  If a connection error occurred
    *
    * @return integer
    */
    public static function get_found_rows($conn, $query, $cache = FALSE)
    {
        $total = 0;

        if ($cache == TRUE)
        {
            $counter_name = 'total_'.md5($query);

            $query        = "SELECT FOUND_ROWS() AS $counter_name";

            $rf           = $conn->CacheExecute($query);
        }
        else
        {
            $counter_name = 'total';

            $query        = "SELECT FOUND_ROWS() AS $counter_name";

            $rf           = $conn->Execute($query);
        }

        if (!$rf)
        {
            Av_exception::throw_error(Av_exception::DB_ERROR, $conn->ErrorMsg());
        }

        if (!$rf->EOF)
        {
            $total = $rf->fields[$counter_name];
        }

        return intval($total);
    }
}

/* End of file ossim_db.inc */
/* Location: ../include/ossim_db.inc */
